// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/token/common/ERC2981.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/**
 * @title NFTCollection
 * @dev ERC721 Token with minting, royalties, and metadata support.
 * Generated by Smart Contract Intelligence Platform.
 */
contract NFTCollection is ERC721Enumerable, ERC721URIStorage, ERC2981, Ownable, ReentrancyGuard {
    using Counters for Counters.Counter;
    using Strings for uint256;

    // Token parameters
    Counters.Counter private _tokenIdCounter;
    uint256 public mintPrice;
    uint256 public maxSupply;
    uint256 public maxMintPerTx;
    bool public mintingActive;
    string public baseURI;
    
    // Mapping for token royalty overrides
    mapping(uint256 => RoyaltyInfo) private _tokenRoyaltyInfo;

    // Events
    event MintingStatusChanged(bool newStatus);
    event MintPriceChanged(uint256 newPrice);
    event RoyaltyInfoChanged(address receiver, uint96 feeNumerator);
    event TokenMinted(address indexed to, uint256 indexed tokenId);

    /**
     * @dev Constructor that initializes the NFT collection
     * @param name_ Name of the collection
     * @param symbol_ Symbol of the collection
     * @param maxSupply_ Maximum supply of tokens that can be minted
     * @param mintPrice_ Price to mint a token in wei
     * @param maxMintPerTx_ Maximum tokens that can be minted in a single transaction
     * @param initialBaseURI_ Base URI for token metadata
     * @param royaltyReceiver Address to receive royalties
     * @param royaltyPercentage Percentage of sale price for royalties (in basis points, 100 = 1%)
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 maxSupply_,
        uint256 mintPrice_,
        uint256 maxMintPerTx_,
        string memory initialBaseURI_,
        address royaltyReceiver,
        uint96 royaltyPercentage
    ) ERC721(name_, symbol_) {
        require(maxSupply_ > 0, "Max supply must be greater than 0");
        require(maxMintPerTx_ > 0, "Max mint per transaction must be greater than 0");
        require(royaltyReceiver != address(0), "Royalty receiver cannot be zero address");
        require(royaltyPercentage <= 10000, "Royalty percentage cannot exceed 100%");
        
        maxSupply = maxSupply_;
        mintPrice = mintPrice_;
        maxMintPerTx = maxMintPerTx_;
        baseURI = initialBaseURI_;
        mintingActive = false;
        
        // Set default royalty
        _setDefaultRoyalty(royaltyReceiver, royaltyPercentage);
    }

    /**
     * @dev Public mint function
     * @param quantity Number of tokens to mint
     */
    function mint(uint256 quantity) external payable nonReentrant {
        require(mintingActive, "Minting is not active");
        require(quantity > 0, "Quantity must be greater than 0");
        require(quantity <= maxMintPerTx, "Exceeds max mint per transaction");
        require(totalSupply() + quantity <= maxSupply, "Exceeds max supply");
        require(msg.value >= mintPrice * quantity, "Insufficient payment");
        
        for (uint256 i = 0; i < quantity; i++) {
            uint256 tokenId = _tokenIdCounter.current();
            _tokenIdCounter.increment();
            _safeMint(msg.sender, tokenId);
            emit TokenMinted(msg.sender, tokenId);
        }
    }

    /**
     * @dev Owner mint function to create tokens with specific URIs
     * @param to Recipient of the token
     * @param quantity Number of tokens to mint
     */
    function ownerMint(address to, uint256 quantity) external onlyOwner {
        require(quantity > 0, "Quantity must be greater than 0");
        require(totalSupply() + quantity <= maxSupply, "Exceeds max supply");
        
        for (uint256 i = 0; i < quantity; i++) {
            uint256 tokenId = _tokenIdCounter.current();
            _tokenIdCounter.increment();
            _safeMint(to, tokenId);
            emit TokenMinted(to, tokenId);
        }
    }

    /**
     * @dev Set token URI for a specific token
     * @param tokenId Token ID to set URI for
     * @param uri New URI for the token
     */
    function setTokenURI(uint256 tokenId, string memory uri) external onlyOwner {
        require(_exists(tokenId), "Token does not exist");
        _setTokenURI(tokenId, uri);
    }

    /**
     * @dev Set the base URI for all tokens
     * @param newBaseURI New base URI
     */
    function setBaseURI(string memory newBaseURI) external onlyOwner {
        baseURI = newBaseURI;
    }

    /**
     * @dev Set the mint price
     * @param newPrice New mint price in wei
     */
    function setMintPrice(uint256 newPrice) external onlyOwner {
        mintPrice = newPrice;
        emit MintPriceChanged(newPrice);
    }

    /**
     * @dev Set the maximum number of tokens that can be minted in a single transaction
     * @param newMaxMintPerTx New maximum mint per transaction
     */
    function setMaxMintPerTx(uint256 newMaxMintPerTx) external onlyOwner {
        require(newMaxMintPerTx > 0, "Max mint per transaction must be greater than 0");
        maxMintPerTx = newMaxMintPerTx;
    }

    /**
     * @dev Toggle minting active status
     * @param active New minting status
     */
    function setMintingActive(bool active) external onlyOwner {
        mintingActive = active;
        emit MintingStatusChanged(active);
    }

    /**
     * @dev Set the default royalty info for all tokens
     * @param receiver Royalty receiver address
     * @param feeNumerator Royalty fee in basis points (100 = 1%)
     */
    function setDefaultRoyalty(address receiver, uint96 feeNumerator) external onlyOwner {
        require(receiver != address(0), "Royalty receiver cannot be zero address");
        require(feeNumerator <= 10000, "Royalty percentage cannot exceed 100%");
        
        _setDefaultRoyalty(receiver, feeNumerator);
        emit RoyaltyInfoChanged(receiver, feeNumerator);
    }

    /**
     * @dev Set royalty info for a specific token
     * @param tokenId Token ID to set royalty for
     * @param receiver Royalty receiver address
     * @param feeNumerator Royalty fee in basis points (100 = 1%)
     */
    function setTokenRoyalty(uint256 tokenId, address receiver, uint96 feeNumerator) external onlyOwner {
        require(_exists(tokenId), "Token does not exist");
        require(receiver != address(0), "Royalty receiver cannot be zero address");
        require(feeNumerator <= 10000, "Royalty percentage cannot exceed 100%");
        
        _setTokenRoyalty(tokenId, receiver, feeNumerator);
    }

    /**
     * @dev Withdraw contract balance to owner
     */
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Transfer failed");
    }

    // Base URI for metadata
    function _baseURI() internal view override returns (string memory) {
        return baseURI;
    }

    // Override functions to support multiple inherited contracts
    function _beforeTokenTransfer(address from, address to, uint256 tokenId, uint256 batchSize)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._beforeTokenTransfer(from, to, tokenId, batchSize);
    }

    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {
        super._burn(tokenId);
        
        // Clear royalty information (if any)
        if (_tokenRoyaltyInfo[tokenId].receiver != address(0)) {
            delete _tokenRoyaltyInfo[tokenId];
        }
    }

    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }

    function supportsInterface(bytes4 interfaceId)
        public
        view
        override(ERC721, ERC721Enumerable, ERC2981)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}