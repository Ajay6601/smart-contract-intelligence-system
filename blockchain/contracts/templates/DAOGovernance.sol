// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "@openzeppelin/contracts/governance/Governor.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorSettings.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorCountingSimple.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotes.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorVotesQuorumFraction.sol";
import "@openzeppelin/contracts/governance/extensions/GovernorTimelockControl.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";
import "@openzeppelin/contracts/utils/Timers.sol";

/**
 * @title DAOGovernance
 * @dev Governance contract with voting, proposals, and timelock functionality.
 * Generated by Smart Contract Intelligence Platform.
 */
contract DAOGovernance is
    Governor,
    GovernorSettings,
    GovernorCountingSimple,
    GovernorVotes,
    GovernorVotesQuorumFraction,
    GovernorTimelockControl
{
    /**
     * @dev Constructor to initialize the DAO governance contract
     * @param _token The ERC20Votes token used for governance
     * @param _timelock The timelock controller
     * @param _name The name of the DAO
     * @param _votingDelay How long after a proposal is created before voting starts (in blocks)
     * @param _votingPeriod How long voting lasts (in blocks)
     * @param _proposalThreshold Minimum amount of votes needed to create a proposal
     * @param _quorumNumerator The numerator of the quorum percentage (denominator is 100)
     */
    constructor(
        ERC20Votes _token,
        TimelockController _timelock,
        string memory _name,
        uint256 _votingDelay,
        uint256 _votingPeriod,
        uint256 _proposalThreshold,
        uint256 _quorumNumerator
    )
        Governor(_name)
        GovernorSettings(
            _votingDelay,
            _votingPeriod,
            _proposalThreshold
        )
        GovernorVotes(_token)
        GovernorVotesQuorumFraction(_quorumNumerator)
        GovernorTimelockControl(_timelock)
    {}

    /**
     * @dev Override required function to determine how voting power is counted
     */
    function COUNTING_MODE() public pure virtual override returns (string memory) {
        return "support=bravo&quorum=for,abstain";
    }

    /**
     * @dev Override required function to get the voting delay in blocks
     */
    function votingDelay() public view override(Governor, GovernorSettings) returns (uint256) {
        return super.votingDelay();
    }

    /**
     * @dev Override required function to get the voting period in blocks
     */
    function votingPeriod() public view override(Governor, GovernorSettings) returns (uint256) {
        return super.votingPeriod();
    }

    /**
     * @dev Override required function to get the proposal threshold
     */
    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {
        return super.proposalThreshold();
    }

    /**
     * @dev Override required function to determine if an account has voted on a proposal
     */
    function hasVoted(uint256 proposalId, address account) public view override(Governor) returns (bool) {
        return super.hasVoted(proposalId, account);
    }

    /**
     * @dev Override required function to get the state of a proposal
     */
    function state(uint256 proposalId) public view override(Governor, GovernorTimelockControl) returns (ProposalState) {
        return super.state(proposalId);
    }

    /**
     * @dev Override required function to create a proposal
     */
    function propose(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        string memory description
    ) public override(Governor) returns (uint256) {
        return super.propose(targets, values, calldatas, description);
    }

    /**
     * @dev Override required function to determine proposal deadline
     */
    function proposalDeadline(uint256 proposalId) public view override(Governor, GovernorSettings) returns (uint256) {
        return super.proposalDeadline(proposalId);
    }

    /**
     * @dev Override required function to queue a proposal for execution
     */
    function _execute(
        uint256 proposalId,
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) {
        super._execute(proposalId, targets, values, calldatas, descriptionHash);
    }

    /**
     * @dev Override required function to cancel a proposal
     */
    function _cancel(
        address[] memory targets,
        uint256[] memory values,
        bytes[] memory calldatas,
        bytes32 descriptionHash
    ) internal override(Governor, GovernorTimelockControl) returns (uint256) {
        return super._cancel(targets, values, calldatas, descriptionHash);
    }

    /**
     * @dev Override required function to get the executor
     */
    function _executor() internal view override(Governor, GovernorTimelockControl) returns (address) {
        return super._executor();
    }

    /**
     * @dev Override required function to check if the contract supports an interface
     */
    function supportsInterface(bytes4 interfaceId) public view override(Governor, GovernorTimelockControl) returns (bool) {
        return super.supportsInterface(interfaceId);
    }
}

/**
 * @title GovernanceToken
 * @dev ERC20 token with voting capabilities for DAO governance
 */
contract GovernanceToken is ERC20Votes {
    /**
     * @dev Constructor to initialize the governance token
     * @param name_ Name of the token
     * @param symbol_ Symbol of the token
     * @param initialSupply Initial supply of tokens to mint
     * @param initialHolder Address to receive the initial supply
     */
    constructor(
        string memory name_,
        string memory symbol_,
        uint256 initialSupply,
        address initialHolder
    ) ERC20(name_, symbol_) ERC20Permit(name_) {
        require(initialHolder != address(0), "Initial holder cannot be zero address");
        _mint(initialHolder, initialSupply);
    }

    /**
     * @dev Hook that is called before any transfer of tokens
     */
    function _beforeTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override {
        super._beforeTokenTransfer(from, to, amount);
    }

    /**
     * @dev Hook that is called after any transfer of tokens
     */
    function _afterTokenTransfer(
        address from,
        address to,
        uint256 amount
    ) internal override(ERC20Votes) {
        super._afterTokenTransfer(from, to, amount);
    }

    /**
     * @dev Hook that is called before minting tokens
     */
    function _mint(address to, uint256 amount) internal override(ERC20Votes) {
        super._mint(to, amount);
    }

    /**
     * @dev Hook that is called before burning tokens
     */
    function _burn(address account, uint256 amount) internal override(ERC20Votes) {
        super._burn(account, amount);
    }
}

/**
 * @title DAOTimelock
 * @dev Timelock controller for DAO governance
 */
contract DAOTimelock is TimelockController {
    /**
     * @dev Constructor to initialize the timelock controller
     * @param minDelay Minimum delay before execution
     * @param proposers List of addresses that can propose
     * @param executors List of addresses that can execute
     */
    constructor(
        uint256 minDelay,
        address[] memory proposers,
        address[] memory executors
    ) TimelockController(minDelay, proposers, executors, msg.sender) {}
}